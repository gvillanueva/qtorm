/*
 * Copyright (C) 2019 Dmitriy Purgin <dmitriy.purgin@sequality.at>
 * Copyright (C) 2019 sequality software engineering e.U. <office@sequality.at>
 *
 * This file is part of QtOrm library.
 *
 * QtOrm is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * QtOrm is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with QtOrm.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "qormpsqlstatementgenerator_p.h"
#include "qormglobal_p.h"
#include "qormquery.h"
#include "qormrelation.h"

QT_BEGIN_NAMESPACE

static QString insertParameter(QVariantMap& boundParameters, QString name, QVariant value)
{
    QString key = ':' % name;

    for (int i = 0; boundParameters.contains(key); ++i)
        key = ':' % name % QString::number(i);

    boundParameters.insert(key, value);

    return key;
}

static QVariant propertyValueForQuery(const QObject* entityInstance,
                                      const QOrmPropertyMapping& propertyMapping)
{
    if (propertyMapping.isReference() && !propertyMapping.isTransient())
    {
        const QOrmMetadata* referencedEntity = propertyMapping.referencedEntity();

        Q_ASSERT(referencedEntity != nullptr);
        Q_ASSERT(referencedEntity->objectIdMapping() != nullptr);

        const QObject* referencedInstance =
            QOrmPrivate::propertyValue(entityInstance, propertyMapping.classPropertyName())
                .value<QObject*>();

        return referencedInstance == nullptr
                   ? QVariant::fromValue(nullptr)
                   : QOrmPrivate::objectIdPropertyValue(referencedInstance, *referencedEntity);
    }
    else
    {
        return QOrmPrivate::propertyValue(entityInstance, propertyMapping.classPropertyName());
    }
}

std::pair<QString, QVariantMap> QOrmPSQLStatementGenerator::generate(const QOrmQuery& query)
{
    QVariantMap boundParameters;
    QString statement = generate(query, boundParameters);

    return std::make_pair(statement, boundParameters);
}

QString QOrmPSQLStatementGenerator::generate(const QOrmQuery& query, QVariantMap& boundParameters)
{
    switch (query.operation())
    {
        case QOrm::Operation::Create:
            return generateInsertStatement(*query.relation().mapping(),
                                           query.entityInstance(),
                                           boundParameters);

//        case QOrm::Operation::Update:
//            return generateUpdateStatement(*query.relation().mapping(),
//                                           query.entityInstance(),
//                                           boundParameters);

//        case QOrm::Operation::Read:
//            return generateSelectStatement(query, boundParameters);

//        case QOrm::Operation::Delete:
//            Q_ASSERT(query.relation().type() == QOrm::RelationType::Mapping);

//            if (query.entityInstance() != nullptr)
//            {
//                return generateDeleteStatement(*query.relation().mapping(),
//                                               query.entityInstance(),
//                                               boundParameters);
//            }
//            else if (query.filter().has_value())
//            {
//                return generateDeleteStatement(*query.relation().mapping(),
//                                               *query.filter(),
//                                               boundParameters);
//            }
//            else
//                Q_ORM_UNEXPECTED_STATE;

        default:
            Q_ORM_UNEXPECTED_STATE;
    }
}

QString QOrmPSQLStatementGenerator::generateInsertStatement(const QOrmMetadata& relation,
                                                            const QObject* entityInstance,
                                                            QVariantMap& boundParameters)
{
    QStringList fieldsList;
    QStringList valuesList;

    for (const QOrmPropertyMapping& propertyMapping : relation.propertyMappings())
    {
        if (propertyMapping.isAutogenerated() || propertyMapping.isTransient())
            continue;

        QVariant propertyValue = propertyValueForQuery(entityInstance, propertyMapping);

        QString valueStr =
            insertParameter(boundParameters, propertyMapping.tableFieldName(), propertyValue);

        fieldsList.push_back(propertyMapping.tableFieldName());
        valuesList.push_back(valueStr);
    }

    QString fieldsStr = fieldsList.join(',');
    QString valuesStr = valuesList.join(',');

    QString statement = QStringLiteral("INSERT INTO %1(%2) VALUES(%3)")
                            .arg(relation.tableName(), fieldsStr, valuesStr);

    return statement;
}

QString QOrmPSQLStatementGenerator::generateCreateTableStatement(
    const QOrmMetadata& entity,
    std::optional<QString> overrideTableName)
{
    QStringList fields;

    for (const QOrmPropertyMapping& mapping : entity.propertyMappings())
    {
        if (mapping.isTransient())
            continue;

        QStringList columnDefs;

        if (mapping.isReference())
        {
            Q_ASSERT(mapping.referencedEntity()->objectIdMapping() != nullptr);

            columnDefs += {mapping.tableFieldName(),
                           toPostgreSqlType(mapping.referencedEntity()->objectIdMapping()->dataType())};
        }
        else
        {
            columnDefs += {mapping.tableFieldName(), toPostgreSqlType(mapping.dataType())};

            if (mapping.isObjectId())
                columnDefs.push_back(QStringLiteral("PRIMARY KEY"));

            if (mapping.isAutogenerated())
                columnDefs.push_back(QStringLiteral("AUTOINCREMENT"));
        }

        fields.push_back(columnDefs.join(' '));
    }

    QString fieldsStr = fields.join(',');

    Q_ASSERT(!overrideTableName.has_value() || !overrideTableName->isEmpty());
    QString effectiveTableName = overrideTableName.value_or(entity.tableName());

    return QStringLiteral("CREATE TABLE %1(%2)").arg(effectiveTableName, fieldsStr);
}

QString QOrmPSQLStatementGenerator::generateDropTableStatement(const QOrmMetadata &entity,
                                                               QVariantMap &boundParameters)
{
    QString parameterKey = insertParameter(boundParameters, ":tableName", entity.tableName());
    return QString{"DROP TABLE %1"}.arg(parameterKey);
}

QString QOrmPSQLStatementGenerator::toPostgreSqlType(QVariant::Type type)
{
    // PostgreSQL data types: https://www.postgresql.org/docs/9.5/datatype.html
    switch (type)
    {
        case QVariant::Int:
            return QStringLiteral("int4");
        case QVariant::UInt:
        case QVariant::LongLong:
        case QVariant::ULongLong:
            return QStringLiteral("int8");

        case QVariant::Double:
            return QStringLiteral("float8");

        case QVariant::Bool:
            return QStringLiteral("bool");
        case QVariant::Time:
            return QStringLiteral("time");
        case QVariant::Date:
        case QVariant::DateTime:
            return QStringLiteral("timestamptz");

        case QVariant::Char:
            return QStringLiteral("char");
        case QVariant::String:
            return QStringLiteral("text");

        default:
            // Additional checks for types not present in QVariant.
            //
            // E.g., there is no QVariant::Long but the type returned for long properties is
            // QMetaType::Long which is 32.
            if (static_cast<QMetaType::Type>(type) == QMetaType::Long)
            {
                return QStringLiteral("int8");
            }
            else if (static_cast<QMetaType::Type>(type) == QMetaType::QVariant)
            {
                return QStringLiteral("text");
            }

            return QStringLiteral("bytea");
    }
}

QT_END_NAMESPACE
